**************************************************************************
Files with this header are meant to be opened in a terminal. 
Use 'less + filename' to open it and look for reference. Each section
is separated by a line of asterisks. Andre Rodriguez. 2015.
**************************************************************************

#### NOTAS DE DIVE INTO PYTHON ####

Before diving into the next chapter, make sure you're comfortable doing all of these things:
• Using the Python IDE to test expressions interactively
• Writing Python programs and running them from within your IDE, or from the command line
• Importing modules and calling their functions
• Declaring functions and using doc strings, local variables, and proper indentation
• Defining dictionaries, tuples, and lists
• Accessing attributes and methods of any object, including strings, lists, dictionaries, functions, and modules
• Concatenating values through string formatting
• Mapping lists into other lists using list comprehensions
• Splitting strings into lists and joining lists into strings

## CHAPTER 4 [INTROSPECTION]

Absolutely everything in Python is a class, although it's not as explicit
as java on telling you so, everything is part of a module, whether it is
built in or imported. Objects have methods, so when you call a function 
you are actually calling a method of said object. 

type, str, dir ---> built in functions

type -> tells you like it is
str --> converts to string
dir --> brings you a list of all the objects methods
callable --> True if the object can be called, False if not

## Calling method function and the method itself:

li = []
li.pop() != li.pop
getattr(li, "append")("Moe") --- calling indirectly, I just got a method (attribute) from the object. Note the quotes. * A pointer!
getattr is super important! Read more on it! It's like using the len function but for files.

## List Mapping

li = [1, 2, 3, 4]
>>> elem*2 for elem in li
'1, 2, 6, 8' 
---> the output is a copy, it's not the same list so assign it to a new variable

## List filtering --> adding a condition

example 1 ####
[mapping-expression for element in source-list if filter-expression]
>>> li = ["a", "mpilgrim", "foo", "b", "c", "b", "d", "d"]
>>> [elem for elem in li if len(elem) > 1]
['mpilgrim', 'foo']

example 2 ####
>>> [elem for elem in li if elem != "b"]
['a', 'mpilgrim', 'foo', 'c', 'd', 'd']
>>> [elem for elem in li if li.count(elem) == 1]
['a', 'mpilgrim', 'foo', 'c']

### AND & OR

and -- returns the last thing that is true or the first thing that is false
empty objects are false by default

>>> 'a' and 'b'
'b'
>>> '' and 'b'
''
>>> 'a' and 'b' and 'c'
'c'

or -- returns the first thing that is true or the last thing that is false
as long as something exists it is true

>>> a or b
'a'
>>> '' or b
'b'
>>> '' or [] or {}
{}

### The AND-OR trick

>>> a = "first"
>>> b = "second"
>>> 1 and a or b
'first'
>>> 0 and a or b
'second'

ERROR WHEN FIRST ELEMENT IS FALSE:
>>> a = ""
>>> b = "second"
>>> 1 and a or b
'second'

FIX:
>>> a = ""
>>> b = "second"
>>> (1 and [a] or [b])[0]
''

BETTER WAY OF DOING IT:

b if a else c

#### LAMBDA FUNCTIONS -- [One liner functions]

>>>def f(x):
...  return x*2
...
>>> f(3)
6
>>> g = lambda x: x*2
>>> g(3)
6
>>> (lambda x: x*2)(3)

Before diving into the next chapter, make sure you're comfortable doing all of these things:
• Defining and calling functions with optional and named arguments
• Using str to coerce any arbitrary value into a string representation
• Using getattr to get references to functions and other attributes dynamically
• Extending the list comprehension syntax to do list filtering
• Recognizing the and−or trick and using it safely
• Defining lambda functions
• Assigning functions to variables and calling the function by referencing the variable. I can't emphasize this
enough, because this mode of thought is vital to advancing your understanding of Python. You'll see more
complex applications of this concept throughout this book.

## CHAPTER 5 [OBJECTS]

'pass' ---> placeholder, is ignored but is not empty

# explicit initialization: when class is a wrapper.
WRAPPER --> The class contains something from another class so when it calls an attribute from
itself it must do it explicitely to avoid confusion. Like the Frame that appears on tkinter when you 
instantiate a window. 

class FileInfo(UserDict):
"store file metadata"
def __init__(self, filename=None):
UserDict.__init__(self)
self["name"] = filename

class FileInfo(dict):
"store file metadata"
def __init__(self, filename=None):
self["name"] = filename

-----

def __getitem__(self, key): return self.data[key]
def __setitem__(self, key, item): self.data[key] = item

__getitem__ and __setitem__ are special methods
you can just call the instance like a dictionary without calling the method
f()
f.__getitem__("name") = g["name"]

CHAPTER 6 [EXCEPTIONS AND FILES]

try:
fsock = open(filename, "rb", 0)
try:
fsock.seek(−128, 2)
tagdata = fsock.read(128)
finally:
fsock.close()
.
.
.
except IOError:
pass
Dive Into Python
	Because opening and reading files is risky and may raise an exception, all of this code is wrapped in a
try...except block. (Hey, isn't standardized indentation great? This is where you start to appreciate it.)
	The open function may raise an IOError. (Maybe the file doesn't exist.)
	The seek method may raise an IOError. (Maybe the file is smaller than 128 bytes.)
	The read method may raise an IOError. (Maybe the disk has a bad sector, or it's on a network drive and the
network just went down.)
	This is new: a try...finally block. Once the file has been opened successfully by the open function, you
want to make absolutely sure that you close it, even if an exception is raised by the seek or read methods.
	That's what a try...finally block is for: code in the finally block will always be executed, even if
something in the try block raises an exception. Think of it as code that gets executed on the way out,
regardless of what happened before.
	At last, you handle your IOError exception. This could be the IOError exception raised by the call to
open, seek, or read. Here, you really don't care, because all you're going to do is ignore it silently and
continue. (Remember, pass is a Python statement that does nothing.) That's perfectly legal; "handling" an
exception can mean explicitly doing nothing. It still counts as handled, and processing will continue normally
on the next line of code after the try...except block.

## CHAPTER 7 [REGULAR EXPRESSIONS]

contained in the 're' module

>>> import re
>>> re.sub('ROAD$', 'RD.', s)
'100 NORTH BROAD RD.'

sub is a replace method
$ --> end of string
^ --> start of string

>>> s = '100 BROAD'
>>> re.sub('ROAD$', 'RD.', s)
'100 BRD.'
>>> re.sub('\\bROAD$', 'RD.', s)
'100 BROAD'
>>> re.sub(r'\bROAD$', 'RD.', s)
'100 BROAD'
>>> s = '100 BROAD ROAD APT. 3'
>>> re.sub(r'\bROAD$', 'RD.', s)
'100 BROAD ROAD APT. 3'
>>> re.sub(r'\bROAD\b', 'RD.', s)
'100 BROAD RD. APT 3'

	What I really wanted was to match 'ROAD' when it was at the end of the string and it was its own
whole word, not a part of some larger word. To express this in a regular expression, you use \b, which
means "a word boundary must occur right here". In Python, this is complicated by the fact that the '\'
character in a string must itself be escaped. This is sometimes referred to as the backslash plague, and it
is one reason why regular expressions are easier in Perl than in Python. On the down side, Perl mixes
regular expressions with other syntax, so if you have a bug, it may be hard to tell whether it's a bug in
syntax or a bug in your regular expression.

	To work around the backslash plague, you can use what is called a raw string, by prefixing the string
with the letter r. This tells Python that nothing in this string should be escaped; '\t' is a tab character,
but r'\t' is really the backslash character \ followed by the letter t. I recommend always using raw
strings when dealing with regular expressions; otherwise, things get too confusing too quickly (and
regular expressions get confusing quickly enough all by themselves).

	*sigh* Unfortunately, I soon found more cases that contradicted my logic. In this case, the street
address contained the word 'ROAD' as a whole word by itself, but it wasn't at the end, because the
address had an apartment number after the street designation. Because 'ROAD' isn't at the very end of
the string, it doesn't match, so the entire call to re.sub ends up replacing nothing at all, and you get
the original string back, which is not what you want.

	To solve this problem, I removed the $ character and added another \b. Now the regular expression
reads "match 'ROAD' when it's a whole word by itself anywhere in the string," whether at the end, the
beginning, or somewhere in the middle.

r before a string --> raw string -- \n\t\n\t these things are escaped
? --> or [any character]

VERBOSE Version --> more readable
"dont read whitespace or comments"

>>> pattern = """
^
M{0,4}
(CM|CD|D?C{0,3})
(XC|XL|L?X{0,3})
(IX|IV|V?I{0,3})
$
"""
>>> re.search(pattern,'M', re.VERBOSE)
<_sre.SRE_Match object at 0x008EEB48>

• ^ matches the beginning of a string.
• $ matches the end of a string.
• \b matches a word boundary.
• \d matches any numeric digit.
• \D matches any non−numeric character.
• x? matches an optional x character (in other words, it matches an x zero or one times).
• x* matches x zero or more times.
• x+ matches x one or more times.
• x{n,m} matches an x character at least n times, but not more than m times.
• (a|b|c) matches either a or b or c.
• (x) in general is a remembered group. You can get the value of what matched by using the groups()
method of the object returned by re.search.

>>> phonePattern = re.compile(r''' 
		# don't match beginning of string, number can start anywhere
(\d{3}) # area code is 3 digits (e.g. '800')
\D* # optional separator is any number of non−digits
(\d{3}) # trunk is 3 digits (e.g. '555')
\D* # optional separator
(\d{4}) # rest of number is 4 digits (e.g. '1212')
\D* # optional separator
(\d*) # extension is optional and can be any number of digits
$ # end of string
''', re.VERBOSE)

>>> phonePattern.search('work 1−(800) 555.1212 #1234').groups()
('800', '555', '1212', '1234')
>>> phonePattern.search('800−555−1212')
('800', '555', '1212', '')




